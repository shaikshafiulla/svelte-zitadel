import { readFileSync, existsSync, writeFileSync } from 'fs';

const ZITADEL_URL = process.env.ZITADEL_URL || 'http://localhost:8080';
let PAT = process.env.PAT;

if (!PAT) {
  if (existsSync('admin.pat')) {
    PAT = readFileSync('admin.pat', 'utf-8').trim();
    console.log('Found admin.pat file, using it for authentication.');
  } else {
    console.error('Error: PAT (Personal Access Token) not found.');
    console.error(' ENV: PAT variable is missing.');
    console.error(' File: admin.pat is missing (generated by docker-compose).');
    process.exit(1);
  }
}

const headers: Record<string, string> = {
  'Authorization': `Bearer ${PAT}`,
  'Content-Type': 'application/json',
};

async function api(method: string, path: string, body?: any) {
  const url = `${ZITADEL_URL}${path}`;
  const response = await fetch(url, {
    method,
    headers,
    body: body ? JSON.stringify(body) : undefined,
  });

  if (!response.ok) {
    const text = await response.text();
    throw new Error(`API Error ${response.status} ${path}: ${text}`);
  }

  return response.json();
}

async function main() {
  console.log('Starting Zitadel Setup (Automated)...');

  // 1. Get Current User & Default Org
  console.log('Verifying Admin...');
  const me = await api('GET', '/auth/v1/users/me');
  console.log(`Authenticated as: ${me.user.userName}`);
  
  let orgId = '';
  if (me.user && me.user.details && me.user.details.resourceOwner) {
      orgId = me.user.details.resourceOwner;
      headers['x-zitadel-orgid'] = orgId;
      console.log(`Using Organization: ${orgId}`);
  } else {
      console.error('Could not determine Organization ID from user context.');
      process.exit(1);
  }

  // 2. Search or Create Project (v1)
  console.log('Checking for Project "SoloDev"...');
  const projectSearch = await api('POST', '/management/v1/projects/_search', {
    queries: [
      { nameQuery: { name: 'SoloDev', method: 'TEXT_QUERY_METHOD_EQUALS' } }
    ]
  });
  
  let projectId: string;
  if (projectSearch.result && projectSearch.result.length > 0) {
    projectId = projectSearch.result[0].id;
    console.log(`Project "SoloDev" already exists: ${projectId}`);
  } else {
    console.log('Creating Project "SoloDev"...');
    const project = await api('POST', '/management/v1/projects', { name: 'SoloDev' });
    projectId = project.id;
    console.log(`Project Created: ${projectId}`);
  }

  // 3. Update Project to Assert Roles on Authentication
  console.log('Updating Project Settings...');
  try {
    await api('PUT', `/management/v1/projects/${projectId}`, {
      name: 'SoloDev',
      projectRoleAssertion: true  // Enable "Assert Roles on Authentication"
    });
    console.log('Project configured to assert roles on authentication');
  } catch (e: any) {
    console.log(`   Project update warning: ${e.message.split('\n')[0]}`);
  }

  // 4. Create Roles
  console.log('Ensuring Roles exist...');
  try {
    await api('POST', `/management/v1/projects/${projectId}/roles`, { roleKey: 'FREELANCER', displayName: 'Freelancer', group: 'Users' });
    await api('POST', `/management/v1/projects/${projectId}/roles`, { roleKey: 'CLIENT', displayName: 'Client', group: 'Users' });
    console.log('Roles defined: FREELANCER, CLIENT');
  } catch (e) {
    console.log('   (Roles might already exist, skipping...)');
  }

  // 5. Create Frontend App (OIDC/PKCE)
  console.log('Checking for Frontend App...');
  const appsSearch = await api('POST', `/management/v1/projects/${projectId}/apps/_search`, { query: { queries: [{ nameQuery: { name: 'SoloDev Web', method: 'TEXT_QUERY_METHOD_EQUALS' } }] } });

  let frontendClientId;
  if (appsSearch.result && appsSearch.result.length > 0 && appsSearch.result[0].oidcConfig) {
    frontendClientId = appsSearch.result[0].oidcConfig.clientId;
    console.log(`Frontend App already exists: ${frontendClientId}`);
  } else {
    console.log('Creating Frontend App...');
    const frontApp = await api('POST', `/management/v1/projects/${projectId}/apps/oidc`, {
      name: 'SoloDev Web',
      redirectUris: ['http://localhost:5173/auth/callback'],
      postLogoutRedirectUris: ['http://localhost:5173/'],
      responseTypes: ['OIDC_RESPONSE_TYPE_CODE'],
      grantTypes: ['OIDC_GRANT_TYPE_AUTHORIZATION_CODE', 'OIDC_GRANT_TYPE_REFRESH_TOKEN'],
      appType: 'OIDC_APP_TYPE_WEB',
      authMethodType: 'OIDC_AUTH_METHOD_TYPE_NONE', // PKCE
      accessTokenType: 'OIDC_TOKEN_TYPE_JWT',
      idTokenUserinfoAssertion: true,
      idTokenRoleAssertion: true,  // Include user roles in ID token
      devMode: true
    });
    frontendClientId = frontApp.clientId;
    console.log(`Frontend App Created: ${frontendClientId}`);
  }

  // 6. Create Backend App (API)
  console.log('Checking for Backend App...');
  let apiClientId, apiClientSecret = 'EXISTS';
  const apiAppsSearch = await api('POST', `/management/v1/projects/${projectId}/apps/_search`, { query: { queries: [{ nameQuery: { name: 'SoloDev API', method: 'TEXT_QUERY_METHOD_EQUALS' } }] } });
  
  if (apiAppsSearch.result && apiAppsSearch.result.length > 0) {
    apiClientId = apiAppsSearch.result[0].apiConfig?.clientId || apiAppsSearch.result[0].id;
    console.log(`Backend App already exists: ${apiClientId}`);
  } else {
    console.log('Creating Backend App...');
    try {
        const apiApp = await api('POST', `/management/v1/projects/${projectId}/apps/api`, {
            name: 'SoloDev API',
            authMethodType: 'API_AUTH_METHOD_TYPE_BASIC'
        });
        apiClientId = apiApp.clientId;
        apiClientSecret = apiApp.clientSecret;
        console.log(`Backend App Created: ${apiClientId}`);
    } catch (e: any) {
        if (e.message.includes('already exists')) {
            const existing = await api('POST', `/management/v1/projects/${projectId}/apps/_search`, { query: { queries: [{ nameQuery: { name: 'SoloDev API', method: 'TEXT_QUERY_METHOD_EQUALS' } }] } });
            apiClientId = existing.result[0]?.apiConfig?.clientId || existing.result[0]?.id;
            console.log(`Backend App already exists (recovered): ${apiClientId}`);
        } else {
            throw e;
        }
    }
  }

  // 7. Create Users (v1)
  console.log('Checking/Creating Users...');
  
  async function ensureUser(email: string, roleKey: string, password: string) {
    const userList = await api('POST', '/management/v1/users/_search', {
      queries: [{ userNameQuery: { userName: email, method: 'TEXT_QUERY_METHOD_EQUALS' } }]
    });

    let userId;
    if (userList.result && userList.result.length > 0) {
      userId = userList.result[0].id;
      console.log(`   User ${email} already exists: ${userId} (Skipping Init Code)`);
    } else {
      console.log(`   Creating User ${email}...`);
      const userRes = await api('POST', '/management/v1/users/human', {
        userName: email,
        profile: { firstName: roleKey, lastName: 'User', displayName: `${roleKey} User`, preferredLanguage: 'en', gender: 'GENDER_UNSPECIFIED' },
        email: { email, isEmailVerified: true },
        initialPassword: password
      });
      userId = userRes.userId;
      console.log(`   User created with password (ACTIVE state): ${userId}`);

      // Append to credentials file
      const { appendFileSync } = await import('fs');
      const creds = `
User: ${email}
Password: ${password}
------------------------------------------------`;
      appendFileSync('user_credentials.txt', creds);
    }

    // Grant Role (v2 CreateAuthorization)

    try {
        await api('POST', '/zitadel.authorization.v2.AuthorizationService/CreateAuthorization', {
            userId,
            projectId,
            organizationId: orgId,
            roleKeys: [roleKey]
        });
        console.log(`      Role ${roleKey} granted`);
    } catch (e: any) {
       if (e.message.includes('AlreadyExists')) {
          console.log(`      Role ${roleKey} already granted`);
       } else {
          console.warn(`      Grant failed: ${e.message.split('\n')[0]}`);
       }
    }
    return email;
  }

  const freelancerEmail = await ensureUser('freelancer@solodev.local', 'FREELANCER', 'Password1!');
  const clientEmail = await ensureUser('client@solodev.local', 'CLIENT', 'Password1!');

  // 8. Auto-update .env file
  console.log('\nUpdating .env file...');
  let envContent = '';
  if (existsSync('.env')) {
    envContent = readFileSync('.env', 'utf-8');
  }

  const updates: Record<string, string> = {
    'ZITADEL_CLIENT_ID': frontendClientId,
    'ZITADEL_PROJECT_ID': projectId,
    'ZITADEL_API_CLIENT_ID': apiClientId
  };
  
  if (apiClientSecret !== 'EXISTS') {
    updates['ZITADEL_API_CLIENT_SECRET'] = apiClientSecret;
  }

  for (const [key, value] of Object.entries(updates)) {
    const regex = new RegExp(`^${key}=.*$`, 'm');
    if (envContent.match(regex)) {
      envContent = envContent.replace(regex, `${key}=${value}`);
    } else {
      envContent += `\n${key}=${value}`;
    }
  }

  writeFileSync('.env', envContent.trim() + '\n');
  console.log('.env file updated successfully.');

  console.log(`ZITADEL_CLIENT_ID=${frontendClientId}`);
  console.log(`ZITADEL_PROJECT_ID=${projectId}`);
  console.log('Login Credentials:');
  console.log(`Freelancer: ${freelancerEmail}  /  Password1!`);
  console.log(`Client:     ${clientEmail}      /  Password1!`);
}

main().catch((err) => {
  console.error('\nSetup Failed:', err.message);
  process.exit(1);
});
